# Planning App — 企业级后端架构设计方案

> 版本：v1.0
> 日期：2026-02-19
> 作者：总设计师（Claude）
> 对标产品：TickTick / Todoist / Notion

---

## 一、现状诊断

| 维度 | 现状 | 评级 |
|------|------|------|
| 基础框架 | Express + Sequelize，结构清晰 | ✅ 良好 |
| 数据库 | MySQL 单机，连接池 max=10 | ⚠️ 存在单点风险 |
| 缓存 | **无** | ❌ 缺失 |
| 消息队列 | **无** | ❌ 缺失 |
| 提醒系统 | alarmService 存在，但无异步投递 | ⚠️ 不可靠 |
| 多端同步 | **无** WebSocket/SSE | ❌ 缺失 |
| 认证 | JWT，无 Token 黑名单 | ⚠️ 安全隐患 |
| 搜索 | **无** | ❌ 缺失 |
| 部署 | 单机 Node 进程 | ❌ 无高可用 |

---

## 二、企业级目标架构

```
UniApp（iOS / Android / H5）
         │
    ┌────┴────┐
    Nginx（反向代理 + 限流 + SSL）
         │
    Node.js 集群（PM2 Cluster Mode）
    ┌────────────────────────────┐
    │  Express API Server × N   │
    │  auth / task / alarm       │
    │  planning / log / sync     │
    └────────────────────────────┘
      │          │          │
   Redis      Bull MQ    MySQL
  (缓存/      (任务队列/   (主从读写
  会话/        提醒投递)    分离)
  黑名单)
      │
   Worker进程（独立）
   - 提醒调度
   - 推送通知
   - 异步统计
```

---

## 三、分阶段实施路线

### Phase 1 — 补齐核心缺口（Week 1~2，最紧迫）

#### 3.1 引入 Redis

```bash
npm install ioredis
```

**用途优先级：**

| 场景 | Key 设计 | TTL |
|------|---------|-----|
| JWT Token 黑名单 | `jwt:blacklist:{jti}` | Token剩余有效期 |
| 用户信息缓存 | `user:{id}` | 30 min |
| 今日任务缓存 | `tasks:today:{user_id}` | 5 min |
| 提醒锁防重发 | `alarm:lock:{alarmId}` | 60 s |

**Cache Aside Pattern（标准缓存策略）：**
```
读：先查Redis → Miss → 查MySQL → 写入Redis
写：先写MySQL → 删除Redis（而非更新，防脏数据）
```

#### 3.2 引入 Bull MQ — 重构提醒系统

**现有问题：** alarmService 的定时任务在主进程内运行，进程重启则提醒丢失。

```bash
npm install bull  # 基于 Redis 的生产级任务队列
```

**新增目录结构：**
```
backend/src/
├── queues/
│   ├── alarmQueue.js       # 队列定义
│   └── workers/
│       └── alarmWorker.js  # 独立消费进程（与主进程分离）
```

**流程：**
```
主进程 → 提醒触发时 → push job 到 Bull 队列（Redis持久化）
Worker进程 → 消费队列 → 发送推送/短信/邮件
进程重启 → 队列中的 job 不丢失
```

#### 3.3 接口限流（安全底线）

```bash
npm install express-rate-limit
```

```javascript
// app.js 补充
const rateLimit = require('express-rate-limit');
app.use('/api/v1/auth/login', rateLimit({
  windowMs: 60 * 1000,
  max: 5,
  message: { code: 429, message: '请求过于频繁，请稍后重试' }
}));
```

---

### Phase 2 — 数据库优化（Week 3）

#### 4.1 必须补充的索引

```sql
-- tasks 表（高频查询）
CREATE INDEX idx_tasks_user_date   ON tasks(user_id, due_date, deleted_at);
CREATE INDEX idx_tasks_user_status ON tasks(user_id, status, deleted_at);

-- alarms 表（定时扫描）
CREATE INDEX idx_alarms_trigger    ON alarms(trigger_at, is_sent, deleted_at);

-- planning_records 表
CREATE INDEX idx_planning_user_type ON planning_records(user_id, type, status);

-- journal_logs 表（时间线查询）
CREATE INDEX idx_logs_user_date    ON journal_logs(user_id, log_date DESC);
```

#### 4.2 MySQL 读写分离配置（生产环境）

```javascript
// config/database.js — production 段升级
production: {
  replication: {
    read: [
      { host: 'slave1.db', username: 'reader', password: '...' },
    ],
    write: { host: 'master.db', username: 'writer', password: '...' }
  },
  pool: {
    max: 20,
    min: 5,
    acquire: 30000,
    idle: 10000
  }
}
```

---

### Phase 3 — 多端实时同步（Week 4，核心体验）

TickTick 最核心的竞争力是**多端秒级同步**，需通过 SSE 实现。

#### 方案：SSE（Server-Sent Events）

```
新增：backend/src/routes/sync.js

GET /api/v1/sync/stream
  → 建立 SSE 长连接
  → 当任务/规划发生变更时推送增量事件
```

**事件类型设计：**
```json
{ "event": "task:updated",    "data": { "taskId": "...", "delta": {} } }
{ "event": "alarm:triggered", "data": { "alarmId": "..." } }
{ "event": "planning:changed","data": { "planningId": "..." } }
```

**同步策略（参考 Notion）：**
```
客户端本地写 → 乐观更新UI（先改UI，用户感知零延迟）
              → 后台异步 sync to server
服务端冲突   → 以 updated_at 最新为准
              → SSE 推送给其他在线端
```

---

### Phase 4 — 可观测性（Month 2）

```bash
npm install @sentry/node  # 错误监控
npm install uuid          # 请求链路追踪
```

**补充 requestId 中间件：**
```javascript
// middleware/requestId.js
const { v4: uuidv4 } = require('uuid');
module.exports = (req, res, next) => {
  req.requestId = uuidv4();
  res.setHeader('X-Request-Id', req.requestId);
  next();
};
```

**监控清单：**
| 工具 | 用途 |
|------|------|
| PM2 监控面板 | 进程状态、内存、CPU |
| Sentry | 异常自动上报、告警 |
| MySQL slow_query_log | 慢查询分析 |
| Winston 结构化日志 | 带 requestId 的链路追踪 |

---

### Phase 5 — 部署工程化（Month 2~3）

**生产部署架构：**
```
Linux 服务器
├── Nginx（443端口，SSL，反向代理到3000）
├── PM2 cluster（利用多核，自动重启）
├── MySQL 主从（1主1从）
├── Redis 单机（或 Sentinel 高可用）
└── OSS 文件存储（替代本地 uploads/）
```

**Docker 化（Month 3）：**
```
docker-compose.yml
├── app（Node.js，PM2）
├── mysql（主库）
├── redis
└── nginx
```

---

## 四、安全加固清单

| 漏洞 | 状态 | 修复方案 |
|------|------|---------|
| JWT 无法主动失效 | ❌ 待修复 | Redis 黑名单，登出时写入 `jwt:blacklist:{jti}` |
| CORS 为 `*` | ❌ 待修复 | 生产环境配置白名单域名 |
| 无接口限流 | ❌ 待修复 | express-rate-limit，登录5次/分钟 |
| SQL注入 | ✅ 已防护 | Sequelize ORM，审查原生查询 |
| 请求体大小限制 | ✅ 已配置 | 10mb，文件上传单独控制 |
| HTTPS | ⚠️ 待配置 | Nginx SSL 证书（Let's Encrypt 免费） |

---

## 五、优先级执行时间表

| 时间 | 任务 | 目标 |
|------|------|------|
| Week 1 | Redis + JWT黑名单 + 接口限流 | 安全底线 |
| Week 2 | Bull MQ + 提醒Worker独立进程 | 提醒可靠性 |
| Week 3 | 数据库索引优化 + 读写分离配置 | 性能基础 |
| Week 4 | SSE实时同步 + requestId链路追踪 | 核心体验 |
| Month 2 | Sentry监控 + PM2集群 + Nginx | 运维能力 |
| Month 3 | Docker化 + CI/CD流水线 | 工程化 |

---

## 六、三条架构红线

**1. 数据一致性优先**
- 写操作：先写 MySQL 成功，再删除 Redis 缓存（绝不反过来）
- 事务范围要小，避免长事务持锁
- 任务/规划数据不能丢

**2. 提醒系统绝对可靠**
- 主进程崩溃不能导致提醒丢失
- Bull MQ 队列持久化到 Redis，进程重启不丢 job
- 提醒锁防止重复发送（Redis SETNX）

**3. 同步速度极快**
- 客户端乐观更新，用户感知零延迟
- SSE 长连接确保其他端实时感知变更
- 多端同步是核心体验，不可妥协

---

## 七、技术选型汇总

| 类别 | 技术 | 说明 |
|------|------|------|
| 运行时 | Node.js v22 | 现有，保持 |
| Web框架 | Express v4 | 现有，保持 |
| ORM | Sequelize v6 | 现有，保持 |
| 主数据库 | MySQL 8 | 现有，加主从 |
| 缓存 | Redis（ioredis） | **新增 - 最优先** |
| 任务队列 | Bull（基于Redis） | **新增** |
| 实时同步 | SSE | **新增** |
| 进程管理 | PM2 cluster | **新增** |
| 反向代理 | Nginx | **新增** |
| 错误监控 | Sentry | **新增** |
| 容器化 | Docker + compose | **规划中** |
| 前端 | UniApp | 现有，保持 |
